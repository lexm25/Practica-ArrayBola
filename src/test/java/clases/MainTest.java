/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package clases;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.InputStream;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.Collections;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer.MethodName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import com.thoughtworks.qdox.JavaDocBuilder;
import com.thoughtworks.qdox.model.JavaSource;

import clases.helpers.Aleatorios;
import ud05arrays.Bola;
import ud05arrays.Ud5Ejercicio1;
import ud05arrays.Ud5Ejercicio2;

/**
 * Esta clase esta preparada para testear el programa main principal de un proyecto
 * interceptando y suplantando tando la entrada como la salida estandar teclado
 * y pantalla
 * @author eserrano
 *
 */
@TestMethodOrder(MethodName.class)
class MainTest {
	
	private final PrintStream standardOut = System.out;
	private final ByteArrayOutputStream outputStreamCaptor = new ByteArrayOutputStream();
	
	
	@BeforeEach
	void setUp() {
	    System.setOut(new PrintStream(outputStreamCaptor));
	}
	
	@Test
	@DisplayName("Compilación")
	/**
	 * Compila y se pueden establecer reglas basicas,
	 * Por ejemplo impedir la importación de ciertas clases 
	 */
	void test00RequisitosBasicos() {
		assertTrue(true);
	}
	
	@Test
	@DisplayName("Crear Bolas")
	/**
	 * toString
	 */
	void test01CrearBolas() {
		//InputStream salida = new ByteArrayInputStream(outputStreamCaptor.toByteArray());
		//Scanner lectorSalida = new Scanner(salida);
		//Main.main(null);
		//assertEquals("Hola Mundo", outputStreamCaptor.toString().trim()/*lectorSalida.nextLine()*/);
		//lectorSalida.close();
		int rows= Aleatorios.numeroAleatorio(5, 50);
		float [][] datosBolas = Aleatorios.arrayFloat(rows, 2, 1f, 10f); 
			
		Bola [] array = Ud5Ejercicio1.crearBolas(datosBolas);
		
		assertEquals(datosBolas.length, array.length);
		
		for(int i=0;i<datosBolas.length;i++) {
			float [] fs = datosBolas[i];
			Bola ref = new Bola(fs[0],fs[1]);
			assertEquals(ref, array[i]);
		}
		
	}
	
	@Test
	@DisplayName("Imprimir Array Bolas")
	/**
	 * toString
	 */
	void test02ImprimeArrayBolas() {
		

		int s = Aleatorios.numeroAleatorio(8, 15);
		Bola [] array = new Bola[s];
		
		for (int i = 0; i < array.length; i++)
			array[i]=new Bola(Aleatorios.numeroAleatorio(1f, 9f),Aleatorios.numeroAleatorio(1f, 9f));
		String titulo = Aleatorios.cadenaAleatoria(5, 8);
		Ud5Ejercicio1.imprimeBolas(array, titulo);
		
		InputStream salida = new ByteArrayInputStream(outputStreamCaptor.toByteArray());
		Scanner lectorSalida = new Scanner(salida);
				
		int lines=0;
		assertEquals(lectorSalida.nextLine(), titulo + ": --------------------");
		lines++;
		
		for(Bola b: array) {
			assertEquals(lectorSalida.nextLine(), b.toString());
			lines++;
		}
		
		assertEquals(lectorSalida.nextLine(), "-----------------------------");
		lines++;
		lectorSalida.close();
		assertEquals(array.length+2,lines);
	}
	
	
	@Test
	@DisplayName("Orden Desdendente")
	/**
	 * toString
	 */
	void test03OrdenDescendente() {
		
		prohibidoArrays();

		int s = Aleatorios.numeroAleatorio(8, 15);
		Bola [] array = new Bola[s];
		
		for (int i = 0; i < array.length; i++)
			array[i]=new Bola(Aleatorios.numeroAleatorio(1f, 9f),Aleatorios.numeroAleatorio(1f, 9f));
		
		Bola [] b = array.clone();
		
		Bola [] ordenado = Ud5Ejercicio1.ordena(array);
		//El contenido de array no ha sido modificado
		assertTrue(Arrays.deepEquals(b, array));
		//El array devuelto es diferente
		assertNotEquals(ordenado, array);
		//El array está ordenado
		Arrays.sort(b, Collections.reverseOrder());
		assertTrue(Arrays.deepEquals(ordenado, b));
	}
	
	@Test
	@DisplayName("Eliminacion elementos")
	/**
	 * toString
	 */
	void test04EliminaBolas() {
		
		prohibidoArrays();
		
		int s = Aleatorios.numeroAleatorio(8, 15);
		Bola [] array = new Bola[s+3];
		
		Bola otra = new Bola(3f,3f);
		array[0]=otra;
		for (int i = 1; i < array.length-2; i++)
			array[i]=new Bola(Aleatorios.numeroAleatorio(1f, 9f),Aleatorios.numeroAleatorio(1f, 9f));
		
		array[array.length-2]=otra;
		array[array.length-1]=otra;
		
		Bola [] b = array.clone();
		
		eliminaElemento(3f, 3f, b);
		
		int elementoAleatorio = Aleatorios.numeroAleatorio(0, array.length-1);
		
		Bola bola2 = array[elementoAleatorio];
		
		eliminaElemento(bola2.getDiametro(), bola2.getPeso(), b);
	}
	
	void eliminaElemento(float diametro, float peso, Bola[]array) {
		
		Bola otra = new Bola(diametro, peso);
        Bola [] b = array.clone();
		
		int  cuenta = 0;
		
		for(Bola pru: array) {
			if(pru.equals(otra))
				cuenta++;
		}
		
		Bola [] eliminacion1 = Ud5Ejercicio1.eliminaBolas(diametro, peso, array);
		//El contenido de array no ha sido modificado
		assertTrue(Arrays.deepEquals(b, array));
		//El array devuelto es diferente
		assertNotEquals(eliminacion1, array);
		//La longitud del array devuelto es coherente
		assertEquals(array.length - cuenta, eliminacion1.length);
		//Comprobar que el eliminado no esta
		Arrays.sort(eliminacion1);
		assertTrue(Arrays.binarySearch(eliminacion1, otra)<0);
		//Comprobar  que los no eliminados estan
		for(Bola ref: array) {
			if(!ref.equals(otra))
				assertTrue(Arrays.binarySearch(eliminacion1, ref)>=0);
		}
	}
	

	@Test
	@DisplayName("Fibo")
	/**
	 * toString
	 */
	void test05Fibo() {
		assertEquals(0,  Ud5Ejercicio2.fibo(0));
		assertEquals(1,  Ud5Ejercicio2.fibo(1));
		assertEquals(1,  Ud5Ejercicio2.fibo(2));
		assertEquals(2,  Ud5Ejercicio2.fibo(3));
		assertEquals(3,  Ud5Ejercicio2.fibo(4));
		assertEquals(5,  Ud5Ejercicio2.fibo(5));
		
		int enesimo = Aleatorios.numeroAleatorio(20, 40);
		
		long prev=5;
		long first=3;
		long valor=0;
		for(int i = 6; i <= enesimo;i++) {
			valor = prev +first;
			first=prev;
			prev=valor;
			
		}
		assertEquals(valor,  Ud5Ejercicio2.fibo(enesimo));
	}
	
	@Test
	@DisplayName("Fibonacci")
	/**
	 * toString
	 */
	void test06Fibonacci() {
	
		long [] tab = new long[41];
		
		
		tab[0]=0;
		assertEquals(1,Ud5Ejercicio2.fibonacci(1).length);
		assertTrue(Arrays.equals(Ud5Ejercicio2.fibonacci(1), 0,1,tab,0,1));
		tab[1]=1;
		assertEquals(2,Ud5Ejercicio2.fibonacci(2).length);
		assertTrue(Arrays.equals(Ud5Ejercicio2.fibonacci(2), 0,2,tab,0,2));
		
		for(int i = 2; i < tab.length;i++) { 
			tab[i] = tab[i-2]+tab[i-1];
			long [] fiboDev = Ud5Ejercicio2.fibonacci(i);
			assertEquals(i,fiboDev.length);
			assertTrue(Arrays.equals(fiboDev, 0,i,tab,0,i));
		}
		
	}
	
	@AfterEach
	void tearDown() {
	    System.setOut(standardOut);
	}
	
	void prohibidoArrays() {
		String fileFullPath = "src/main/java/ud05arrays/Ud5Ejercicio1.java";
		compruebaProhibido(fileFullPath, "Arrays");
	}
	
	void compruebaProhibido(String classFullPath, String classForbidden) {
        JavaDocBuilder builder = new JavaDocBuilder();
        try {
			builder.addSource(new FileReader( classFullPath  ));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
			assertTrue(false);
		}

        JavaSource src = builder.getSources()[0];
        String[] imports = src.getImports();

        for ( String imp : imports )
        {
            if(imp.endsWith("."+ classForbidden)) {
            	print("Prohibido importar " + classForbidden + " en la clase " + classFullPath );
            	assertTrue(false);
            }
            if( imp.endsWith(".*")) {
            	print("Prohibido importar con .*" + " en la clase " + classFullPath );
            	assertTrue(false);
            }
        }
        
        String sc = src.getCodeBlock();
        
        Pattern pattern = Pattern.compile(classForbidden + "\\.");
        Matcher matcher = pattern.matcher(sc);
        if(matcher.find()) {
        	print("Prohibido referenciar " + classForbidden + " en la clase " + classFullPath );
        	assertTrue(false);
        }
	}
	
	void print(Object message) {
		this.standardOut.println(message);
	}

}